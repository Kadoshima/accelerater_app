# 実装時の判断と根拠

## 1. アーキテクチャ設計の判断

### 1.1 サービス分離の方針
**判断**: 機能ごとに独立したサービスクラスを作成
**根拠**:
- 単一責任の原則（SRP）に従い、各クラスが明確な責任を持つ
- テストの容易性：各サービスを独立してテスト可能
- 再利用性：他のプロジェクトでも使用可能なモジュール設計

### 1.2 既存システムの拡張 vs 新規実装
**判断**: `ExtendedDataRecorder`として既存の`SensorDataRecorder`を継承
**根拠**:
- 基本的なデータ記録機能は既存実装を活用
- 拡張部分のみ追加実装することで開発効率向上
- 既存システムとの互換性維持

---

## 2. アルゴリズム実装の判断

### 2.1 最小二乗法による位相予測
**判断**: 過去10歩分のデータで線形回帰
**根拠**:
- 10歩は約10秒分のデータで、短期的なトレンドを捉えるのに適切
- 計算コストが低く、リアルタイム処理に適している
- 線形モデルで歩行の位相変化を十分に近似可能

### 2.2 予測値と実測値のブレンド比率
**判断**: 実測値70%、予測値30%の重み付け
**根拠**:
```dart
correctedError = error * 0.7 + predictedError * 0.3;
```
- 実測値を重視しつつ、予測で補正
- 過度な予測依存による不安定性を回避
- 実験的に良好な結果が得られる比率

### 2.3 ゲインパラメータの値
**判断**: kφ = 0.35, kT = 0.10
**根拠**:
- 研究計画書で指定された値を使用
- 位相ゲインを大きくして素早い収束
- 周期ゲインを小さくして安定性確保

---

## 3. データ同期の設計判断

### 3.1 相対タイムスタンプの使用
**判断**: セッション開始時刻からの相対時間を記録
**根拠**:
```dart
Duration relativeTime = timestamp.difference(sessionStartTime);
```
- 異なるデバイス間の時刻ずれを補正
- データ解析時の時間軸整合性向上
- ドリフトの影響を最小化

### 3.2 バッファサイズの決定
**判断**: 最大1000件（約10秒分）のバッファ
**根拠**:
- IMU 100Hzで10秒 = 1000データポイント
- メモリ使用量と処理遅延のバランス
- リアルタイム表示に必要十分な長さ

### 3.3 Polar H10の3秒更新への対応
**判断**: 専用の同期エラー計算を実装
**根拠**:
- 固定間隔（3秒）の特性を活用
- 期待値からのずれを定量化
- 異常検出に活用可能

---

## 4. UI/UX設計の判断

### 4.1 音声認識とボタン入力の併用
**判断**: 音声認識を主、ボタン入力を副とする設計
**根拠**:
- 歩行中は音声入力が自然
- 環境音や認識精度の問題に備えてフォールバック必要
- ユーザーの選択肢を提供

### 4.2 数字表示のアニメーション
**判断**: スケールとフェードのアニメーション実装
**根拠**:
```dart
_scaleAnimation = Tween<double>(begin: 0.8, end: 1.0)
_fadeAnimation = Tween<double>(begin: 0.0, end: 1.0)
```
- 視覚的な変化で注意を引く
- 滑らかな遷移で目の疲労軽減
- 300msの短時間で完了

### 4.3 フィードバックの即時性
**判断**: 正解/不正解を即座に表示
**根拠**:
- 学習効果の向上
- モチベーション維持
- リアルタイムな課題遂行感

---

## 5. 実験制御の設計判断

### 5.1 ラテン方格法の実装
**判断**: 6×6の標準ラテン方格を使用
**根拠**:
```dart
final latinSquare = [
  [0, 1, 2, 3, 4, 5],
  [1, 2, 3, 4, 5, 0],
  // ...
];
```
- 順序効果のカウンターバランス
- 実装の簡潔性
- 統計解析への適合性

### 5.2 休憩時間の段階的設定
**判断**: 条件数に応じて1-3分の休憩
**根拠**:
- 実験の進行に伴う疲労の蓄積を考慮
- 被験者の集中力維持
- 実験全体の時間効率

### 5.3 フェーズ自動遷移
**判断**: タイマーによる自動進行
**根拠**:
- 実験者の操作ミス防止
- 正確なタイミング制御
- 実験の標準化

---

## 6. エラーハンドリングの方針

### 6.1 音声衝突の閾値
**判断**: 200ms以内を衝突と判定
**根拠**:
- 人間の聴覚的な分離閾値を考慮
- 音声の重なりによる認識困難を回避
- 十分な安全マージン

### 6.2 タイムアウト時間
**判断**: N-back応答は2秒でタイムアウト
**根拠**:
- 次の数字提示までの時間を考慮
- 反応時間の妥当な上限
- 課題の流れを維持

### 6.3 データ欠損時の処理
**判断**: 欠損を記録しつつ実験継続
**根拠**:
- 実験の中断を最小限に
- 後処理での補完可能性
- 部分的なデータでも価値がある

---

## 7. パフォーマンス最適化

### 7.1 ストリーム処理の採用
**判断**: データ配信にStreamを使用
**根拠**:
- リアクティブな更新
- メモリ効率的な処理
- 複数のリスナーに対応

### 7.2 バッファのフラッシュ戦略
**判断**: 5秒ごと or 1000件でフラッシュ
**根拠**:
- I/O頻度とデータ安全性のバランス
- システムクラッシュ時のデータ損失最小化
- ストレージへの負荷分散

---

## 8. 将来の拡張性考慮

### 8.1 認知負荷の追加
**判断**: enumで管理、簡単に追加可能な設計
**根拠**:
```dart
enum CognitiveLoad { none, nBack0, nBack1, nBack2 }
```
- 新しい課題タイプの追加が容易
- コードの可読性維持
- 型安全性の確保

### 8.2 多言語対応
**判断**: 言語コードベースの設計
**根拠**:
- 国際的な研究での使用を想定
- TTSエンジンの言語サポート活用
- 最小限のコード変更で対応可能

### 8.3 データフォーマットの拡張性
**判断**: JSON形式で追加データを保存
**根拠**:
- スキーマの柔軟な変更
- 後方互換性の維持
- 解析ツールとの連携容易性

---

## 9. セキュリティとプライバシー

### 9.1 音声データの扱い
**判断**: 音声認識結果のみ保存、音声自体は保存しない
**根拠**:
- プライバシー保護
- ストレージ容量の節約
- 必要十分な情報の記録

### 9.2 被験者IDの管理
**判断**: 匿名化されたIDを使用
**根拠**:
- 個人情報保護
- 研究倫理への準拠
- データ解析には影響なし

---

## 10. テスト戦略（未実装部分）

### 10.1 単体テストの優先順位
**判断**: アルゴリズム部分を優先
**根拠**:
- ビジネスロジックの正確性が最重要
- UIテストは後回しでも影響小
- 数値計算の検証が必須

### 10.2 統合テストのシナリオ
**判断**: 実際の実験フローに沿ったE2Eテスト
**根拠**:
- 実験の完全性保証
- エッジケースの発見
- リグレッションの防止